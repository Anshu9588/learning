Of course. Here are the answers to the most common interview questions on modern ES6+ JavaScript syntax.

---

### \#\# High Importance

#### \#\#\# 1. Explain destructuring assignment for objects and arrays.

**Destructuring** is a convenient syntax for "unpacking" values from arrays or properties from objects into distinct variables.

- **Object Destructuring** unpacks properties based on their **name**.
  ```javascript
  const person = {
    firstName: "Jane",
    age: 30,
  };
  // Extracts the `firstName` and `age` properties into variables
  const { firstName, age } = person;
  console.log(firstName); // "Jane"
  console.log(age); // 30
  ```
- **Array Destructuring** unpacks values based on their **position** (index).
  ```javascript
  const colors = ["red", "green", "blue"];
  // Extracts values by their position
  const [firstColor, secondColor] = colors;
  console.log(firstColor); // "red"
  console.log(secondColor); // "green"
  ```

---

#### \#\#\# 2. How do you set default values when destructuring?

You can provide a default value using the `=` operator. The default is used if the property/element is `undefined` or doesn't exist.

- **Object Default Value**:
  ```javascript
  const user = { name: "Alex" };
  const { name, role = "Guest" } = user;
  console.log(name); // "Alex"
  console.log(role); // "Guest" (since `role` was not in the object)
  ```
- **Array Default Value**:
  ```javascript
  const data = [100];
  const [value, timestamp = Date.now()] = data;
  console.log(value); // 100
  console.log(timestamp); // A default timestamp is provided
  ```

---

#### \#\#\# 3. What are rest parameters? How do they differ from the `arguments` object?

**Rest parameters** (`...`) provide a way to collect an indefinite number of function arguments into a single, true **array**.

The key differences from the older `arguments` object are:

- **Type**: Rest parameters create a **true array**, so you can immediately use array methods like `.map()`, `.filter()`, and `.sort()`. The `arguments` object is only **array-like** and lacks these methods.
- **Scope**: Rest parameters only collect the "rest" of the arguments that haven't been explicitly named. The `arguments` object contains _all_ arguments passed to the function.
- **Modernity**: Rest parameters are the modern, cleaner, and more flexible way to handle variable arguments.

<!-- end list -->

```javascript
// `...args` is a true array
function sum(...args) {
  return args.reduce((total, num) => total + num, 0);
}
console.log(sum(1, 2, 3)); // 6
```

---

#### \#\#\# 4. What is the spread operator? How can you use it with arrays and objects?

The **spread operator** (`...`) does the opposite of rest parameters: it **expands** an iterable (like an array) or an object's properties into individual elements.

- **With Arrays**: You can use it to create new arrays, merge arrays, or pass array elements as function arguments.
  ```javascript
  const parts = ["shoulders", "knees"];
  const body = ["head", ...parts, "toes"]; // ['head', 'shoulders', 'knees', 'toes']
  ```
- **With Objects**: You can use it to clone or merge objects.
  ```javascript
  const user = { name: "John", age: 40 };
  const userWithRole = { ...user, role: "Admin" }; // { name: 'John', age: 40, role: 'Admin' }
  ```

---

#### \#\#\# 5. Show how to merge two arrays and two objects using the spread operator.

This is one of the most common uses of the spread operator.

- **Merging Arrays**:
  ```javascript
  const arr1 = [1, 2, 3];
  const arr2 = [4, 5, 6];
  const mergedArray = [...arr1, ...arr2];
  console.log(mergedArray); // [1, 2, 3, 4, 5, 6]
  ```
- **Merging Objects**: If objects have conflicting keys, the property from the **later object** in the sequence wins.
  ```javascript
  const obj1 = { name: "Alice", theme: "light" };
  const obj2 = { isAdmin: true, theme: "dark" };
  const mergedObject = { ...obj1, ...obj2 };
  // `theme` from `obj2` overwrites `theme` from `obj1`
  console.log(mergedObject); // { name: 'Alice', theme: 'dark', isAdmin: true }
  ```

---

#### \#\#\# 6. Explain template literals. How do they improve string concatenation?

**Template literals** are an enhanced way to create strings in JavaScript, using backticks (`` ` ``) instead of single or double quotes.

They improve upon traditional string concatenation (`+`) in two key ways:

1.  **Readability**: They allow for **string interpolation**â€”embedding expressions directly into the string with `${expression}` syntax. This is much cleaner and easier to read than breaking the string and using `+`.
2.  **Multi-line Strings**: They support multi-line strings natively, without needing to add newline characters (`\n`).

---

#### \#\#\# 7. How do you embed expressions and multi-line strings with template literals?

- **Embedding Expressions**: Place any valid JavaScript expression inside `${...}`.
  ```javascript
  const user = { name: "Bob", items: 3 };
  const message = `Hello, ${user.name.toUpperCase()}! You have ${
    user.items * 2
  } items in your cart.`;
  console.log(message); // "Hello, BOB! You have 6 items in your cart."
  ```
- **Multi-line Strings**: Simply press Enter to create a new line. The line breaks are preserved in the final string.
  ```javascript
  const htmlBlock = `
    <div>
      <h1>Welcome</h1>
      <p>This is a multi-line string.</p>
    </div>
  `;
  ```

---

#### \#\#\# 8. What are default function parameters? How do they work?

**Default function parameters** allow you to initialize named parameters with a default value if no value or `undefined` is passed.

The default value is applied when an argument is either:

- Not provided at all.
- Explicitly passed as `undefined`.

It will **not** be applied for other "falsy" values like `null`, `0`, `false`, or an empty string `""`. This makes them safer than the old `||` pattern.

```javascript
function greet(name = "Guest", message = "Welcome!") {
  console.log(`${message}, ${name}.`);
}

greet("Alice", "Hello"); // "Hello, Alice."
greet("Bob"); // "Welcome!, Bob." (uses default message)
greet(undefined, "Hi"); // "Hi, Guest." (uses default name)
greet(); // "Welcome!, Guest." (uses both defaults)
greet(null); // "Welcome!, null." (null is a valid value)
```

---

### \#\# Medium Importance

#### \#\#\# 9. Demonstrate refactoring a function into ES6+ syntax.

- **Before (ES5)**:
  ```javascript
  function createMessage(user, text) {
    var user = user || { name: "Anonymous" };
    var message = "User " + user.name + " says: " + text;
    return message;
  }
  ```
- **After (ES6+)**:
  ```javascript
  const createMessage = (user = { name: "Anonymous" }, text) => {
    return `User ${user.name} says: ${text}`;
  };
  ```
  This version uses an arrow function, a default parameter for the `user` object, and a template literal for clean string creation.

---

#### \#\#\# 10. How can you use rest parameters to handle variable arguments? Compare with `arguments`.

Rest parameters are superior because they produce a **true array**.

- **With Rest Parameters (`...args`)**:
  ```javascript
  function logArgs(...args) {
    // `args` is a real array, so we can use .map()
    args.map((arg) => console.log(arg));
  }
  ```
- **With `arguments` object (Old way)**:
  ```javascript
  function logArgsOld() {
    // `arguments` is array-like, so we must convert it first
    const argsArray = Array.from(arguments);
    argsArray.map((arg) => console.log(arg));
  }
  ```

---

#### \#\#\# 11. Explain computing property names in object literals.

ES6 allows you to use an expression in square brackets `[]` to define an object's property key dynamically.

```javascript
const propName = "status";
const user = {
  id: 123,
  [propName]: "active", // The key will be 'status'
  ["role" + "_id"]: 5, // The key will be 'role_id'
};
console.log(user); // { id: 123, status: 'active', role_id: 5 }
```

---

#### \#\#\# 12. How do you perform deep cloning, and what are the limitations of spread?

The spread (`...`) operator performs a **shallow clone**. It copies top-level properties. If a property is a nested object or array, only the _reference_ (the memory address) is copied, not the object itself.

**Limitation**: Modifying a nested object in the "clone" will also modify the original.

For a **deep clone**, you need to recursively copy every nested object.

- **Easy way**: `JSON.parse(JSON.stringify(obj))`. This is simple but has limitations (loses `undefined`, functions, and can't handle circular references).
- **Modern way**: `structuredClone(obj)`. This is a new, built-in function that handles complex data types and circular references correctly.

---

#### \#\#\# 13. What is the difference between spread in function calls vs. array literals?

The concept of "expanding" is the same, but the context differs.

- **In Function Calls**: It unpacks an array's elements into **individual arguments**.
  ```javascript
  const numbers = [10, 5, 25];
  console.log(Math.max(...numbers)); // Same as Math.max(10, 5, 25)
  ```
- **In Array Literals**: It unpacks an array's elements into a **new array**.
  ```javascript
  const numbers = [10, 5, 25];
  const newArray = [1, ...numbers, 30]; // [1, 10, 5, 25, 30]
  ```

---

#### \#\#\# 14. How do you use destructuring in function parameters?

You can destructure an object or array directly in a function's signature. This makes the code self-documenting by clearly showing what properties the function expects.

```javascript
// Destructuring an object in the function signature
function UserCard({ name, age, avatarUrl = "default.png" }) {
  console.log(`Displaying card for ${name}, age ${age}.`);
  // ... render logic using name, age, and avatarUrl
}

UserCard({ name: "Sarah", age: 32 });
```

---

#### \#\#\# 15. Explain how to use nested destructuring.

You can mirror the structure of your data to extract deeply nested properties.

```javascript
const response = {
  data: {
    user: {
      id: 7,
      profile: {
        name: "Leo",
        address: {
          city: "Tokyo",
        },
      },
    },
  },
};

// Mirror the structure to extract `city`
const {
  data: {
    user: {
      profile: {
        address: { city },
      },
    },
  },
} = response;
console.log(city); // "Tokyo"
```

---

#### \#\#\# 16. How do you rename variables when destructuring objects?

You use a colon (`:`) to assign the property to a new variable name.

```javascript
const person = { id: 42, name: "Zoe" };
// Extract `id` into a variable named `personId`
// Extract `name` into a variable named `personName`
const { id: personId, name: personName } = person;

console.log(personId); // 42
console.log(personName); // "Zoe"
```

---

### \#\# Low Importance

17. **Tagged Template Literals**: A function call that uses a template literal. The function receives the string parts and expression values as separate arguments, allowing for custom processing. A common use case is in styling libraries like `styled-components` (e.g., `const Title = styled.h1` \`font-size: 1.5em;\` \`;\`).
18. **Rest Operator for Objects**: You can use the rest operator (`...`) in destructuring to collect the remaining properties of an object into a new object.
    ```javascript
    const user = { id: 1, name: "Admin", theme: "dark", lang: "en" };
    const { id, ...userProfile } = user;
    // userProfile is now { name: 'Admin', theme: 'dark', lang: 'en' }
    ```
19. **Polyfill**: Before ES6 was widely supported, developers used "polyfills"â€”code that replicates new features in older environments. For example, a default parameter `function(a = 1)` could be polyfilled with `if (a === undefined) { a = 1; }`. Today, tools like **Babel** transpile modern syntax into older, compatible code automatically.
20. **Performance Implications**: For most applications, the performance cost is negligible. However, since spread/rest operations create new arrays/objects, using them inside tight loops with very large datasets can cause memory pressure. In such rare, performance-critical scenarios, a mutable `for` loop might be faster.
21. **Skipped Elements & Rest**: In array destructuring, you can use a comma to skip an element. The rest pattern will then collect all remaining elements.
    ```javascript
    const arr = [1, 2, 3, 4, 5];
    const [first, , third, ...rest] = arr; // Skips the second element (2)
    // first is 1, third is 3, rest is [4, 5]
    ```
22. **Defaults in Arrow Functions**: They work exactly the same as in traditional functions. `const greet = (name = 'Guest') => `Hello, ${name}`;`.
23. **Conditionally Include Properties**: You can use spread with a short-circuited logical AND (`&&`). If the condition is false, `false` is spread, which adds no properties. If true, the object is spread.
    ```javascript
    const isAdmin = true;
    const user = {
      name: "Sam",
      ...(isAdmin && { role: "Admin", permissions: ["all"] }),
    }; // user will include role and permissions
    ```
24. **Shallow vs. Deep Copying**: Spread creates a **shallow copy**. It copies top-level properties. If a property is a nested object, only the reference is copied. A **deep copy** recursively copies all nested objects, creating a completely independent clone.
25. **Sanitization with Tags**: You can create a tag function that takes a template literal, iterates through its string and value parts, and escapes any potentially harmful HTML characters from the values before combining them.
26. **Pitfalls with Mutable Defaults**: If you use a mutable object (like an array or object) as a default parameter, it's recreated for each call. The main pitfall comes from older patterns where a default object was shared across calls, leading to unintended mutations. ES6 default parameters largely avoid this issue.
27. **Convert NodeList/arguments to Array**: The spread operator is the cleanest way. `const nodes = document.querySelectorAll('div'); const elementsArray = [...nodes];`.
28. **Rest and Destructuring in Signatures**: You can combine them to handle complex arguments. For example, `function processCoordinates([x, y, ...rest])` would destructure the first two elements of an array argument and collect the rest.
29. **Computed Properties with Destructuring**: You can use a destructured variable to define a key in a new object.
    ```javascript
    const user = { id: 123, name: "Admin" };
    const { id } = user;
    const userById = { [id]: user }; // { '123': { id: 123, name: 'Admin' } }
    ```
30. **Template Literals & XSS**: A security risk (Cross-Site Scripting) exists if you use a template literal to construct HTML and inject **unsanitized user input** directly into it. For example, `element.innerHTML = `\<div\>${userInput}\</div\>`;`. If `userInput` contains malicious script tags, they will be executed. This is a vulnerability of `innerHTML`, not template literals themselves. Always sanitize user input.
